ReadMe File
Overview: My program has the basic features any image software would have. The controls for the 
first part of this project can be found in the file menu at the top of the screen. I have considered 
the fact that more options besides grayscale will become available, which can be added at the bottom of the 
grayscale button. The picture can be opened from a .png file, edited, then saved to the same file. The program has 
two choices for grayscaling, using either parallel programming or sequential. The program also has two choices for 
blurring an image, also using either parallel or sequential. Equalization was implemented and also has the option to 
either choose parallel or sequantial computting.

File Types Supported: PNG

Bugs: Once again, a big fallback this program has is that you cannot undo any action, so any accidental move that needs
to be fixed is requird to completly reload the picture, losing all progress made. 

The parallel equalization isn't necessarily all parallel. One kernel, the kernel that creates the modified list of 
grayscale values from the input/output histogram, pretty much the last step, does not work. This is very annoying since 
this is a simple kernel and is probably a very stupid error I am making, however I cannot seem to debug it. One loop
was added to do this part sequentially and the picture is equalized fine.

										*UPDATE PHASE 5*
I could not get my optimized algorithm to produce a correct histogram and theres probably a couple reasons why. First,
i'll explain the strategy I planned to use. The only size tile that would work for this algorithm is 16*16, and we can
now use to local index to place the value of that index in the correct place in the collection of histograms. Therefore,
we have to have a global and local work group size that can work for this. To make sure htis works, I created a new variable
that I would use as the global width and global height that is the next hightest number divisible by 16 for both the height
and weight of the actual image. Essentially, I want my kernel to scan more than the image is and discard any indexes that
are overhanging the picture. Once I had this, I had all my parameters for the kernel that I was optimizing. 



